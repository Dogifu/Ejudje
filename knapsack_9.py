'''
Весь алгоритм скрыт от 
внешнего кода и предоставляет лишь 
интерфейс через функцию knapsack_fptas, 
что является формой инкапсуляции.
Для решения данной задачи применим алгоритм
FPTAS (Fully Polynomial-Time Approximation Scheme)
Основная идея заключается в том, чтобы использовать 
масштабирование (scaling) для управления точностью 
приближенного решения в зависимости от величины входных данных.
'''


from typing import List, Tuple

'''
Функция knapsack_fptas:
Эта функция является основной функцией, в которой реализован 
весь алгоритм FPTAS для задачи о рюкзаке. Внутри нее выполняются следующие шаги:
1) Определение максимальной стоимости предмета и масштаба для округления (max_cost и scale).
2) Вложенная функция solve, которая осуществляет решение задачи о рюкзаке с помощью FPTAS.
3) Возврат результата в виде кортежа: общего веса (total_weight), 
общей стоимости (total_cost) и индексов выбранных предметов (items_ids).
'''


def knapsack_fptas(epsilon: float, capacity: int, items: List[Tuple[int, int]]) -> Tuple[int, int, List[int]]:
    max_cost = max(item[1] for item in items)
    scale = epsilon * max_cost / (len(items) * (1 + epsilon))

    '''
    Эта вложенная функция используется внутри knapsack_fptas 
    для решения задачи о рюкзаке. Внутри нее выполняются следующие шаги:
    1) Инициализация переменной sols словарем, где ключ — текущая стоимость, 
    а значение — кортеж с индексами предметов, общим весом и общей стоимостью.
    2) Перебор предметов и обновление словаря sols с учетом добавления текущего предмета.
    3) Возврат лучшего решения.
    '''
    def solve():
        sols = {0: ([], 0, 0)}
        # Создается словарь sols, в котором ключ — текущая стоимость,
        # а значение — кортеж с индексами предметов, общим весом и общей стоимостью.
        # Изначально устанавливается значение для случая, когда рюкзак пуст.

        # Происходит перебор всех предметов во входных данных. Происходит перебор всех предметов во входных данных.
        # используется для получения идентификатора предмета
        for item_id, (weight, cost) in enumerate(items):
            '''
            хранения копии текущего состояния словаря sols. 
            Это делается для того, чтобы внутри цикла можно 
            было модифицировать sols, не затрагивая текущее состояние.
            '''
            solution_copy = dict(sols)
            '''
             Для каждого состояния из solution_copy рассчитывается новый вес 
             и стоимость при добавлении текущего предмета. 
             Если новое состояние улучшает текущее или является новым, оно добавляется в словарь sols.
            '''
            for key, (ids, total_weight, total_cost) in solution_copy.items():
                new_weight, new_cost = total_weight + \
                    weight, total_cost + int(cost / scale)
                if new_weight <= capacity and (new_cost not in sols or new_weight < sols[new_cost][1]):
                    sols[new_cost] = (ids + [item_id], new_weight, new_cost)
        '''
        По завершении цикла возвращается лучшее решение с наибольшей стоимостью. 
        Функция max используется с параметром key=lambda x: x[2], 
        чтобы выбрать решение с максимальной стоимостью.
        '''
        return max(sols.values(), key=lambda x: x[2])

    best_solution = solve()
    total_cost = sum(items[item_id][1] for item_id in best_solution[0])
    return best_solution[1], total_cost, best_solution[0]


'''
Вычисление временной сложности :)
1. Определение максимальной стоимости и масштабирование (O(n)):

Проход по всем предметам для нахождения максимальной стоимости
— O(n), где n - количество предметов.
Вычисление масштаба — константное время.

2. Функция solve (вложенная в knapsack_fptas):

Для каждого предмета выполняется два вложенных цикла. 
Внутренний цикл проходит по всем возможным состояниям решения.
Каждая итерация циклов выполняется за константное время, 
и общее число итераций может быть аппроксимировано как O(n * W), 
где W - максимальный общий вес предметов в рюкзаке.
Поиск лучшего решения в словаре также занимает O(W) времени.

3. Поиск итогового решения:
Суммирование стоимостей предметов — O(n).
Общая временная сложность knapsack_fptas определяется 
временной сложностью функции solve, которая составляет O(n * W).

Вывод: общая временная сложность программы, реализующей FPTAS 
для задачи о рюкзаке, составляет примерно O(n * W), где n - количество предметов, 
а W - максимальный общий вес предметов, который может поместиться в рюкзак.
'''


def main():
    '''
    Необходимости в обработке ошибок ввода нет,
    так как в ТЗ об это не сказано ни слова, 
    и мы рассчитываем на то, что наш User
    будет вводить все корректно
    '''
    try:
        epsilon = float(input())
        capacity = int(input())
    except EOFError:
        return

    items = []
    while True:
        try:
            line = input()
        except EOFError:
            break
        if not line:
            continue
        items.append(tuple(map(int, line.split())))

    result = knapsack_fptas(epsilon, capacity, items)
    print(result[0], result[1])
    print(*[item_id + 1 for item_id in result[2]], sep='\n')


if __name__ == '__main__':
    main()
